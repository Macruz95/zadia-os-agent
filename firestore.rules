rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user is the owner of the document
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    // Helper function to check user role via Custom Claims (secure)
    function hasRole(role) {
      return isAuthenticated() && request.auth.token.role == role;
    }
    
    // Helper function to check if user has admin role
    function isAdmin() {
      return hasRole('admin');
    }
    
    // Helper function to check if user has manager or admin role
    function isManagerOrAdmin() {
      return hasRole('manager') || hasRole('admin');
    }
    
    // Users collection - users can only read/write their own profile
    match /users/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId) && isValidUserData();
      allow update: if isOwner(userId) && isValidUserUpdate();
      allow delete: if isAdmin(); // Only admins can delete users
      
      // Validate user data on creation
      function isValidUserData() {
        let data = request.resource.data;
        return data.keys().hasAll(['email', 'displayName', 'role', 'language', 'createdAt', 'lastLogin', 'isActive']) &&
               data.role == 'user' && // New users can only be created with 'user' role
               data.email == request.auth.token.email &&
               data.isActive == true;
      }
      
      // Validate user data on update - prevent role escalation
      function isValidUserUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return !data.diff(existingData).affectedKeys().hasAny(['role', 'email', 'createdAt']) ||
               isAdmin(); // Only admins can change critical fields
      }
    }
    
    // Clients collection - secured with proper authentication
    match /clients/{clientId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidClientData();
      allow update: if isAuthenticated() && (isOwnerData(clientId) || isManagerOrAdmin()) && isValidClientUpdate();
      allow delete: if isAuthenticated() && isAdmin();
      
      function isOwnerData(clientId) {
        return resource.data.createdBy == request.auth.uid;
      }
      
      function isValidClientData() {
        let data = request.resource.data;
        return data.keys().hasAll(['name', 'documentId', 'clientType', 'status', 'createdBy', 'createdAt']) &&
               data.clientType in ['PersonaNatural', 'Organización', 'Empresa'] &&
               data.status in ['Potencial', 'Activo', 'Inactivo'];
      }
      
      function isValidClientUpdate() {
        let data = request.resource.data;
        let existingData = resource.data;
        return !data.diff(existingData).affectedKeys().hasAny(['createdBy', 'createdAt']) ||
               isAdmin();
      }
    }

    // Contacts collection - secured with client ownership validation
    match /contacts/{contactId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidContactData();
      allow update: if isAuthenticated() && (isContactOwner(contactId) || isManagerOrAdmin());
      allow delete: if isAuthenticated() && (isContactOwner(contactId) || isAdmin());
      
      function isContactOwner(contactId) {
        return resource.data.clientId != null && 
               exists(/databases/$(database)/documents/clients/$(resource.data.clientId)) &&
               get(/databases/$(database)/documents/clients/$(resource.data.clientId)).data.createdBy == request.auth.uid;
      }
      
      function isValidContactData() {
        let data = request.resource.data;
        return data.keys().hasAll(['clientId', 'phone', 'createdBy']) &&
               data.createdBy == request.auth.uid &&
               exists(/databases/$(database)/documents/clients/$(data.clientId));
      }
    }

    // Interactions collection - client activity tracking
    match /interactions/{interactionId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidInteractionData();
      allow update: if isAuthenticated() && (isInteractionOwner(interactionId) || isManagerOrAdmin());
      allow delete: if isAuthenticated() && isAdmin();
      
      function isInteractionOwner(interactionId) {
        return resource.data.createdBy == request.auth.uid;
      }
      
      function isValidInteractionData() {
        let data = request.resource.data;
        return data.keys().hasAll(['clientId', 'type', 'createdBy', 'createdAt']) &&
               data.type in ['call', 'email', 'meeting', 'note', 'task'] &&
               exists(/databases/$(database)/documents/clients/$(data.clientId));
      }
    }

    // Transactions collection - financial transactions
    match /transactions/{transactionId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidTransactionData();
      allow update: if isAuthenticated() && isManagerOrAdmin();
      allow delete: if isAuthenticated() && isAdmin();
      
      function isValidTransactionData() {
        let data = request.resource.data;
        return data.keys().hasAll(['type', 'amount', 'createdBy', 'createdAt']) &&
               data.amount is number && data.amount >= 0 &&
               data.type in ['income', 'expense', 'transfer'];
      }
    }

    // Interactions collection - secured with client ownership validation
    match /interactions/{interactionId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidInteractionData();
      allow update: if isAuthenticated() && (isInteractionOwner(interactionId) || isManagerOrAdmin());
      allow delete: if isAuthenticated() && isAdmin();
      
      function isInteractionOwner(interactionId) {
        return resource.data.clientId != null && 
               exists(/databases/$(database)/documents/clients/$(resource.data.clientId)) &&
               get(/databases/$(database)/documents/clients/$(resource.data.clientId)).data.createdBy == request.auth.uid;
      }
      
      function isValidInteractionData() {
        let data = request.resource.data;
        return data.keys().hasAll(['clientId', 'type', 'createdBy']) &&
               exists(/databases/$(database)/documents/clients/$(data.clientId));
      }
    }

    // Transactions collection - secured with authentication and validation
    match /transactions/{transactionId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidTransactionData();
      allow update: if isAuthenticated() && (isTransactionOwner(transactionId) || isManagerOrAdmin());
      allow delete: if isAuthenticated() && isAdmin();
      
      function isTransactionOwner(transactionId) {
        return resource.data.createdBy == request.auth.uid;
      }
      
      function isValidTransactionData() {
        let data = request.resource.data;
        return data.keys().hasAll(['clientId', 'amount', 'type', 'status', 'createdBy']) &&
               data.amount is number && data.amount >= 0;
      }
    }

    // Projects collection - secured with authentication
    match /projects/{projectId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidProjectData();
      allow update: if isAuthenticated() && (isProjectOwner(projectId) || isManagerOrAdmin());
      allow delete: if isAuthenticated() && isAdmin();
      
      function isProjectOwner(projectId) {
        return resource.data.createdBy == request.auth.uid || 
               request.auth.uid in resource.data.members;
      }
      
      function isValidProjectData() {
        let data = request.resource.data;
        return data.keys().hasAll(['name', 'clientId', 'status', 'createdBy']) &&
               exists(/databases/$(database)/documents/clients/$(data.clientId));
      }
    }

    // Quotes collection - secured with authentication
    match /quotes/{quoteId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidQuoteData();
      allow update: if isAuthenticated() && (isQuoteOwner(quoteId) || isManagerOrAdmin());
      allow delete: if isAuthenticated() && isAdmin();
      
      function isQuoteOwner(quoteId) {
        return resource.data.createdBy == request.auth.uid;
      }
      
      function isValidQuoteData() {
        let data = request.resource.data;
        return data.keys().hasAll(['clientId', 'total', 'status', 'createdBy']) &&
               data.total is number && data.total >= 0;
      }
    }

    // Orders collection - secured with authentication
    match /orders/{orderId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidOrderData();
      allow update: if isAuthenticated() && (isOrderOwner(orderId) || isManagerOrAdmin());
      allow delete: if isAuthenticated() && isAdmin();
      
      function isOrderOwner(orderId) {
        return resource.data.createdBy == request.auth.uid;
      }
      
      function isValidOrderData() {
        let data = request.resource.data;
        return data.keys().hasAll(['clientId', 'total', 'status', 'createdBy', 'createdAt']) &&
               data.total is number && data.total >= 0 &&
               data.status in ['pending', 'confirmed', 'in-production', 'completed', 'cancelled', 'on-hold'];
      }
    }

    // Invoices collection - secured with authentication
    match /invoices/{invoiceId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidInvoiceData();
      allow update: if isAuthenticated() && (isInvoiceOwner(invoiceId) || isManagerOrAdmin());
      allow delete: if isAuthenticated() && isAdmin();
      
      function isInvoiceOwner(invoiceId) {
        return resource.data.createdBy == request.auth.uid;
      }
      
      function isValidInvoiceData() {
        let data = request.resource.data;
        return data.keys().hasAll(['clientId', 'total', 'status', 'createdBy', 'createdAt']) &&
               data.total is number && data.total >= 0 &&
               data.status in ['draft', 'pending', 'paid', 'overdue', 'cancelled'];
      }
    }

    // Payments collection - secured with authentication
    match /payments/{paymentId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidPaymentData();
      allow update: if isAuthenticated() && isManagerOrAdmin();
      allow delete: if isAuthenticated() && isAdmin();
      
      function isValidPaymentData() {
        let data = request.resource.data;
        return data.keys().hasAll(['invoiceId', 'amount', 'paymentMethod', 'createdBy', 'createdAt']) &&
               data.amount is number && data.amount > 0 &&
               data.paymentMethod in ['cash', 'transfer', 'check', 'card', 'other'];
      }
    }

    // Meetings collection - secured with authentication
    match /meetings/{meetingId} {
      allow read: if isAuthenticated() && (isMeetingParticipant(meetingId) || isManagerOrAdmin());
      allow create: if isAuthenticated() && isManagerOrAdmin() && isValidMeetingData();
      allow update: if isAuthenticated() && (isMeetingParticipant(meetingId) || isManagerOrAdmin());
      allow delete: if isAuthenticated() && isAdmin();
      
      function isMeetingParticipant(meetingId) {
        return resource.data.createdBy == request.auth.uid ||
               request.auth.uid in resource.data.attendees;
      }
      
      function isValidMeetingData() {
        let data = request.resource.data;
        return data.keys().hasAll(['date', 'attendees', 'createdBy']) &&
               data.createdBy == request.auth.uid &&
               data.attendees is list;
      }
    }    // Tasks collection - project-based access
    match /tasks/{taskId} {
      allow read, write: if isAuthenticated() && 
        (request.auth.uid == resource.data.assignedTo || 
         request.auth.uid == resource.data.createdBy ||
         isManagerOrAdmin());
    }

    // ====================================================================
    // INVENTORY MODULE - Raw Materials, Finished Products, BOM, Movements
    // Enhanced security rules with granular access control
    // ====================================================================
    
    // Helper function to check warehouse/inventory roles
    function hasInventoryAccess() {
      return isAuthenticated() && 
             (hasRole('admin') || hasRole('manager') || hasRole('warehouse') || hasRole('production'));
    }
    
    // Helper function to check if user can modify inventory
    function canModifyInventory() {
      return isAuthenticated() && (hasRole('admin') || hasRole('manager') || hasRole('warehouse'));
    }
    
    // Raw Materials collection - granular access control
    match /raw-materials/{materialId} {
      // Read: Any authenticated user can view inventory
      allow read: if isAuthenticated();
      
      // Create: Managers, admins, and warehouse staff can create materials
      allow create: if canModifyInventory() && isValidRawMaterialCreate();
      
      // Update: Managers, admins, and warehouse can update (but not stock directly)
      allow update: if canModifyInventory() && isValidRawMaterialUpdate();
      
      // Delete: Only admins can soft-delete (mark as inactive)
      allow delete: if isAdmin();
      
      function isValidRawMaterialCreate() {
        let data = request.resource.data;
        return data.keys().hasAll(['name', 'sku', 'category', 'unitOfMeasure', 'currentStock', 'minimumStock', 'unitCost', 'averageCost', 'createdBy', 'createdAt', 'isActive']) &&
               data.name is string && data.name.size() > 0 &&
               data.sku is string && data.sku.size() > 0 &&
               data.category in ['Maderas', 'Acabados', 'Adhesivos', 'Herrajes', 'Químicos', 'Textiles', 'Herramientas', 'Otros'] &&
               data.currentStock is number && data.currentStock >= 0 &&
               data.minimumStock is number && data.minimumStock >= 0 &&
               data.unitCost is number && data.unitCost >= 0 &&
               data.averageCost is number && data.averageCost >= 0 &&
               data.createdBy == request.auth.uid &&
               data.isActive == true;
      }
      
      function isValidRawMaterialUpdate() {
        let data = request.resource.data;
        let existing = resource.data;
        let changedKeys = data.diff(existing).affectedKeys();
        
        // Prevent direct stock updates (must use inventory-movements)
        return !changedKeys.hasAny(['currentStock', 'createdBy', 'createdAt', 'sku']) &&
               data.isActive is bool;
      }
    }

    // Finished Products collection - granular access control
    match /finished-products/{productId} {
      // Read: Any authenticated user can view products
      allow read: if isAuthenticated();
      
      // Create: Managers, admins, and production staff can create products
      allow create: if canModifyInventory() && isValidFinishedProductCreate();
      
      // Update: Managers, admins, and production can update (but not stock directly)
      allow update: if canModifyInventory() && isValidFinishedProductUpdate();
      
      // Delete: Only admins can soft-delete
      allow delete: if isAdmin();
      
      function isValidFinishedProductCreate() {
        let data = request.resource.data;
        return data.keys().hasAll(['name', 'sku', 'category', 'currentStock', 'minimumStock', 'unitCost', 'laborCost', 'overheadCost', 'totalCost', 'suggestedPrice', 'sellingPrice', 'status', 'createdBy', 'createdAt', 'isActive']) &&
               data.name is string && data.name.size() > 0 &&
               data.sku is string && data.sku.size() > 0 &&
               data.category in ['Dormitorio', 'Oficina', 'Sala', 'Cocina', 'Comedor', 'Baño', 'Infantil', 'Exterior', 'Otros'] &&
               data.currentStock is number && data.currentStock >= 0 &&
               data.minimumStock is number && data.minimumStock >= 0 &&
               data.unitCost is number && data.unitCost >= 0 &&
               data.laborCost is number && data.laborCost >= 0 &&
               data.overheadCost is number && data.overheadCost >= 0 &&
               data.totalCost is number && data.totalCost >= 0 &&
               data.suggestedPrice is number && data.suggestedPrice >= 0 &&
               data.sellingPrice is number && data.sellingPrice >= 0 &&
               data.status in ['Disponible', 'Reservado', 'Vendido', 'FueraDeCatalogo', 'EnProduccion'] &&
               data.createdBy == request.auth.uid &&
               data.isActive == true;
      }
      
      function isValidFinishedProductUpdate() {
        let data = request.resource.data;
        let existing = resource.data;
        let changedKeys = data.diff(existing).affectedKeys();
        
        // Prevent direct stock updates and cost changes without proper authorization
        return !changedKeys.hasAny(['currentStock', 'createdBy', 'createdAt', 'sku']) &&
               data.isActive is bool &&
               data.status in ['Disponible', 'Reservado', 'Vendido', 'FueraDeCatalogo', 'EnProduccion'];
      }
    }

    // Bill of Materials (BOM) collection - manage product recipes
    match /bill-of-materials/{bomId} {
      // Read: Any authenticated user can view BOMs
      allow read: if isAuthenticated();
      
      // Create: Only managers, admins, and production can create BOMs
      allow create: if hasInventoryAccess() && isValidBOMCreate();
      
      // Update: Only managers and admins can update BOMs
      allow update: if isManagerOrAdmin() && isValidBOMUpdate();
      
      // Delete: Only admins can deactivate BOMs
      allow delete: if isAdmin();
      
      function isValidBOMCreate() {
        let data = request.resource.data;
        return data.keys().hasAll(['finishedProductId', 'finishedProductName', 'version', 'items', 'totalMaterialCost', 'estimatedLaborHours', 'laborCostPerHour', 'totalLaborCost', 'overheadPercentage', 'totalOverheadCost', 'totalCost', 'isActive', 'createdBy', 'createdAt']) &&
               data.finishedProductId is string &&
               data.version is number && data.version > 0 &&
               data.items is list && data.items.size() > 0 &&
               data.totalMaterialCost is number && data.totalMaterialCost >= 0 &&
               data.estimatedLaborHours is number && data.estimatedLaborHours >= 0 &&
               data.laborCostPerHour is number && data.laborCostPerHour >= 0 &&
               data.totalLaborCost is number && data.totalLaborCost >= 0 &&
               data.overheadPercentage is number && data.overheadPercentage >= 0 &&
               data.totalOverheadCost is number && data.totalOverheadCost >= 0 &&
               data.totalCost is number && data.totalCost >= 0 &&
               data.createdBy == request.auth.uid &&
               data.isActive == true;
      }
      
      function isValidBOMUpdate() {
        let data = request.resource.data;
        let existing = resource.data;
        let changedKeys = data.diff(existing).affectedKeys();
        
        // Cannot change finishedProductId or version after creation
        return !changedKeys.hasAny(['finishedProductId', 'version', 'createdBy', 'createdAt']) &&
               data.isActive is bool;
      }
    }

    // Inventory Movements collection - immutable audit trail
    match /inventory-movements/{movementId} {
      // Read: Any authenticated user can view movements
      allow read: if isAuthenticated();
      
      // Create: Warehouse, production, managers, and admins can register movements
      allow create: if hasInventoryAccess() && isValidMovementCreate();
      
      // Update: Movements are IMMUTABLE (audit trail) - only admins for corrections
      allow update: if isAdmin() && isValidMovementCorrection();
      
      // Delete: Only admins can delete movements (should be rare)
      allow delete: if isAdmin();
      
      function isValidMovementCreate() {
        let data = request.resource.data;
        return data.keys().hasAll(['itemId', 'itemType', 'itemName', 'itemSku', 'movementType', 'quantity', 'unitCost', 'totalCost', 'previousStock', 'newStock', 'performedBy', 'performedAt']) &&
               data.itemId is string &&
               data.itemType in ['raw-material', 'finished-product'] &&
               data.movementType in ['Entrada', 'Salida', 'Ajuste', 'Merma', 'Produccion', 'Venta', 'Devolucion'] &&
               data.quantity is number && data.quantity != 0 &&
               data.unitCost is number && data.unitCost >= 0 &&
               data.totalCost is number &&
               data.previousStock is number && data.previousStock >= 0 &&
               data.newStock is number && data.newStock >= 0 &&
               data.performedBy == request.auth.uid;
      }
      
      function isValidMovementCorrection() {
        let data = request.resource.data;
        let existing = resource.data;
        let changedKeys = data.diff(existing).affectedKeys();
        
        // Only reason/notes can be updated for corrections
        return changedKeys.hasOnly(['reason', 'notes']) &&
               isAdmin();
      }
    }

    // Inventory Alerts collection - low stock and critical notifications
    match /inventory-alerts/{alertId} {
      // Read: Any authenticated user can view alerts
      allow read: if isAuthenticated();
      
      // Create: System-generated or managers/admins
      allow create: if hasInventoryAccess() && isValidAlertCreate();
      
      // Update: Mark as read or resolve alerts
      allow update: if isAuthenticated() && isValidAlertUpdate();
      
      // Delete: Only admins can delete alerts
      allow delete: if isAdmin();
      
      function isValidAlertCreate() {
        let data = request.resource.data;
        return data.keys().hasAll(['itemId', 'itemType', 'itemName', 'alertType', 'currentStock', 'minimumStock', 'priority', 'isRead', 'createdAt']) &&
               data.itemType in ['raw-material', 'finished-product'] &&
               data.alertType in ['low-stock', 'out-of-stock', 'obsolete', 'reorder'] &&
               data.priority in ['low', 'medium', 'high', 'critical'] &&
               data.isRead == false;
      }
      
      function isValidAlertUpdate() {
        let data = request.resource.data;
        let existing = resource.data;
        let changedKeys = data.diff(existing).affectedKeys();
        
        // Only allow marking as read or adding readBy info
        return changedKeys.hasOnly(['isRead', 'readBy', 'readAt']) &&
               data.isRead is bool;
      }
    }

    // ====================================================================
    // SALES MODULE - Leads, Opportunities, Conversion Pipeline
    // ====================================================================
    
    // Leads collection - manage sales leads
    match /leads/{leadId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidLeadData();
      allow update: if isAuthenticated() && (isLeadOwner(leadId) || isManagerOrAdmin());
      allow delete: if isAuthenticated() && (isLeadOwner(leadId) || isAdmin());
      
      function isLeadOwner(leadId) {
        return resource.data.createdBy == request.auth.uid ||
               (resource.data.assignedTo != null && resource.data.assignedTo == request.auth.uid);
      }
      
      function isValidLeadData() {
        let data = request.resource.data;
        return data.keys().hasAll(['firstName', 'email', 'status', 'source', 'priority', 'createdBy', 'createdAt']) &&
               data.status in ['nuevo', 'contactado', 'calificado', 'no-calificado', 'convertido'] &&
               data.priority in ['baja', 'media', 'alta', 'urgente'];
      }
    }

    // Opportunities collection - converted leads and sales pipeline
    match /opportunities/{opportunityId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidOpportunityData();
      allow update: if isAuthenticated() && (isOpportunityOwner(opportunityId) || isManagerOrAdmin());
      allow delete: if isAuthenticated() && isAdmin();
      
      function isOpportunityOwner(opportunityId) {
        return resource.data.createdBy == request.auth.uid ||
               (resource.data.assignedTo != null && resource.data.assignedTo == request.auth.uid);
      }
      
      function isValidOpportunityData() {
        let data = request.resource.data;
        return data.keys().hasAll(['name', 'stage', 'value', 'createdBy', 'createdAt']) &&
               data.stage in ['prospecto', 'calificacion', 'propuesta', 'negociacion', 'cierre', 'ganada', 'perdida'] &&
               data.value is number && data.value >= 0;
      }
    }
    
    // ====================================================================
    // GEOGRAPHICAL DATA - Countries, Departments, Municipalities, Districts
    // ====================================================================
    
    // Countries collection - public read, admin write (geographical reference data)
    match /countries/{countryId} {
      allow read: if true;  // Public geographical data
      allow write: if isAdmin();
    }
    
    // Departments collection - public read, admin write
    match /departments/{departmentId} {
      allow read: if true;  // Public geographical data
      allow write: if isAdmin();
    }
    
    // Municipalities collection - public read, admin write
    match /municipalities/{municipalityId} {
      allow read: if true;  // Public geographical data
      allow write: if isAdmin();
    }
    
    // Districts collection - public read, admin write
    match /districts/{districtId} {
      allow read: if true;  // Public geographical data
      allow write: if isAdmin();
    }
    
    // ====================================================================
    // PHONE CODES - International dialing codes
    // ====================================================================
    
    // Phone Codes collection - public read, admin write
    match /phoneCodes/{phoneCodeId} {
      allow read: if true;  // Public reference data
      allow write: if isAdmin();
    }
    
    // Analytics collection - admin only
    match /analytics/{document} {
      allow read, write: if isAdmin();
    }
    
    // System logs - admin only
    match /logs/{logId} {
      allow read: if isAdmin();
      allow write: if false; // Logs should only be written by server-side functions
    }
    
    // ====================================================================
    // PROJECTS MODULE - Independent first-level module
    // ====================================================================
    
    // Projects collection
    match /projects/{projectId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidProjectData();
      allow update: if isAuthenticated() && (isProjectMember(projectId) || isManagerOrAdmin());
      allow delete: if isAdmin();
      
      function isProjectMember(projectId) {
        return request.auth.uid == resource.data.projectManager ||
               request.auth.uid in resource.data.teamMembers ||
               request.auth.uid == resource.data.createdBy;
      }
      
      function isValidProjectData() {
        let data = request.resource.data;
        return data.keys().hasAll(['name', 'clientId', 'status', 'createdBy', 'projectType']) &&
               data.status in ['planning', 'in-progress', 'on-hold', 'completed', 'cancelled'] &&
               data.priority in ['low', 'medium', 'high', 'urgent'] &&
               data.projectType in ['production', 'service', 'internal'] &&
               data.salesPrice is number && data.salesPrice >= 0 &&
               data.estimatedCost is number && data.estimatedCost >= 0;
      }
    }
    
    // Work Orders collection
    match /workOrders/{workOrderId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isValidWorkOrderData();
      allow update: if isAuthenticated() && (isWorkOrderAssignee(workOrderId) || isManagerOrAdmin());
      allow delete: if isAdmin();
      
      function isWorkOrderAssignee(workOrderId) {
        return request.auth.uid == resource.data.assignedTo ||
               request.auth.uid == resource.data.createdBy;
      }
      
      function isValidWorkOrderData() {
        let data = request.resource.data;
        return data.keys().hasAll(['projectId', 'name', 'status', 'createdBy']) &&
               data.status in ['pending', 'in-progress', 'paused', 'completed', 'cancelled'] &&
               exists(/databases/$(database)/documents/projects/$(data.projectId));
      }
    }
    
    // Project Tasks collection
    match /projectTasks/{taskId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update: if isAuthenticated() && (isTaskAssignee(taskId) || isManagerOrAdmin());
      allow delete: if isAuthenticated() && (isTaskCreator(taskId) || isAdmin());
      
      function isTaskAssignee(taskId) {
        return request.auth.uid == resource.data.assignedTo;
      }
      
      function isTaskCreator(taskId) {
        return request.auth.uid == resource.data.createdBy;
      }
    }
    
    // Project Timeline collection
    match /projectTimeline/{entryId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update: if false; // Timeline entries are immutable
      allow delete: if isAdmin();
    }
    
    // Work Sessions collection (time tracking)
    match /workSessions/{sessionId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAdmin();
    }
    
    // Default deny for any other paths
    match /{document=**} {
      allow read, write: if false;
    }
  }
}